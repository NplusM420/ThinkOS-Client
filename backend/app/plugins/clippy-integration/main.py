"""
Clippy Integration Plugin for ThinkOS

Integrates with the Clipper platform to create video clips using the Clippy AI agent.
Allows ThinkOS agents to send video URLs and prompts to Clipper and receive
generated clips with captions and aspect ratios.

The clips are automatically saved as memories in ThinkOS for future reference.
"""

import json
from typing import Any
from datetime import datetime


class Plugin:
    """
    Clippy integration plugin that connects ThinkOS with the Clipper platform.
    
    Configuration (set via plugin settings):
    - clipper_api_url: Base URL of the Clipper API (e.g., http://localhost:5000)
    - clipper_api_key: API key for authenticating with Clipper
    - webhook_enabled: Whether to use webhooks for async clip delivery
    - auto_save_clips: Automatically save returned clips as memories
    """
    
    DEFAULT_CLIPPER_URL = "http://localhost:5000"
    
    def __init__(self, api: Any):
        self.api = api
        self.api.log("info", "Clippy Integration plugin initialized")
    
    async def on_load(self) -> None:
        """Load plugin settings from config."""
        # Settings are loaded from plugin config (set via Settings UI)
        api_url = self.api.get_config("clipper_api_url", self.DEFAULT_CLIPPER_URL)
        api_key = self.api.get_config("clipper_api_key", "")
        auto_save = self.api.get_config("auto_save_clips", True)
        
        self.api.log("info", f"Clippy Integration loaded - API URL: {api_url}")
        if not api_key:
            self.api.log("warning", "Clipper API key not configured. Go to Settings > Plugins > Clippy to set it up.")
    
    async def on_unload(self) -> None:
        """Cleanup on unload."""
        self.api.log("info", "Clippy Integration plugin unloaded")
    
    def register_tools(self) -> list[dict]:
        """Register Clippy tools for ThinkOS agents."""
        return [
            {
                "name": "clippy_create_clips",
                "description": "Send a video URL to Clippy AI agent to create clips based on a prompt. Clippy will analyze the video, find the best moments, and return clips with captions and aspect ratio recommendations. Use this when the user wants to create short clips from a video.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "video_url": {
                            "type": "string",
                            "description": "URL of the video to create clips from (YouTube, direct video URL, etc.)"
                        },
                        "prompt": {
                            "type": "string",
                            "description": "Instructions for what kind of clips to create (e.g., 'Find the funniest moments', 'Create educational highlights', 'Extract key product demos')"
                        },
                        "target_platform": {
                            "type": "string",
                            "description": "Target social media platform for the clips",
                            "enum": ["tiktok", "youtube_shorts", "instagram_reels", "linkedin", "twitter", "general"],
                            "default": "general"
                        },
                        "max_clips": {
                            "type": "number",
                            "description": "Maximum number of clips to generate (1-10)",
                            "default": 5
                        },
                        "include_captions": {
                            "type": "boolean",
                            "description": "Whether to include auto-generated captions",
                            "default": True
                        }
                    },
                    "required": ["video_url", "prompt"]
                },
                "handler": self.create_clips_handler
            },
            {
                "name": "clippy_check_status",
                "description": "Check the status of a clip generation job that was previously submitted to Clippy",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "job_id": {
                            "type": "string",
                            "description": "The job ID returned from clippy_create_clips"
                        }
                    },
                    "required": ["job_id"]
                },
                "handler": self.check_status_handler
            },
            {
                "name": "clippy_get_clip",
                "description": "Get details and download URL for a specific clip that was generated by Clippy",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "clip_id": {
                            "type": "string",
                            "description": "The clip ID to retrieve"
                        }
                    },
                    "required": ["clip_id"]
                },
                "handler": self.get_clip_handler
            },
            {
                "name": "clippy_status",
                "description": "Check the current Clippy integration configuration status. Shows if API key is configured and the current API URL. Settings are managed via Settings > Plugins > Clippy Video Clipper.",
                "parameters": {
                    "type": "object",
                    "properties": {},
                    "required": []
                },
                "handler": self.configure_handler
            }
        ]
    
    async def create_clips_handler(self, params: dict) -> dict:
        """
        Send a video to Clippy for clip generation.
        
        This calls the Clipper API's /api/v1/clippy/generate endpoint.
        """
        video_url = params.get("video_url", "")
        prompt = params.get("prompt", "")
        target_platform = params.get("target_platform", "general")
        max_clips = min(max(int(params.get("max_clips", 5)), 1), 10)
        include_captions = params.get("include_captions", True)
        
        if not video_url:
            return {"success": False, "error": "video_url is required"}
        
        if not prompt:
            return {"success": False, "error": "prompt is required"}
        
        api_key = self.api.get_config("clipper_api_key", "")
        if not api_key:
            return {
                "success": False,
                "error": "Clipper API key not configured. Go to Settings > Plugins > Clippy to set it up."
            }
        
        api_url = self.api.get_config("clipper_api_url", self.DEFAULT_CLIPPER_URL)
        
        try:
            # Call Clipper's Clippy agent endpoint
            response = await self.api.http_request(
                method="POST",
                url=f"{api_url}/api/v1/clippy/generate",
                headers={
                    "Authorization": f"Bearer {api_key}",
                    "Content-Type": "application/json"
                },
                body=json.dumps({
                    "videoUrl": video_url,
                    "prompt": prompt,
                    "targetPlatform": target_platform,
                    "maxClips": max_clips,
                    "includeCaptions": include_captions,
                    "callbackUrl": None  # Could add webhook support later
                }),
                timeout=120.0  # Video processing can take time
            )
            
            if response["status_code"] == 401:
                return {"success": False, "error": "Invalid Clipper API key"}
            
            if response["status_code"] == 404:
                return {
                    "success": False,
                    "error": "Clippy endpoint not found. Make sure Clipper has the /api/v1/clippy/generate endpoint enabled."
                }
            
            if response["status_code"] != 200 and response["status_code"] != 202:
                return {
                    "success": False,
                    "error": f"Clipper API error: {response['status_code']} - {response.get('body', '')}"
                }
            
            result = json.loads(response["body"])
            
            # If clips are returned immediately (sync mode)
            if result.get("clips"):
                clips = result["clips"]
                
                # Auto-save clips as memories if enabled
                if self.api.get_config("auto_save_clips", True):
                    await self._save_clips_as_memories(clips, video_url, prompt)
                
                return {
                    "success": True,
                    "result": {
                        "status": "completed",
                        "video_url": video_url,
                        "clips_count": len(clips),
                        "clips": clips
                    }
                }
            
            # If async mode, return job ID
            return {
                "success": True,
                "result": {
                    "status": "processing",
                    "job_id": result.get("jobId"),
                    "message": result.get("message", "Clip generation started"),
                    "estimated_time": result.get("estimatedTime", "1-5 minutes")
                }
            }
            
        except Exception as e:
            self.api.log("error", f"Clippy API error: {e}")
            return {"success": False, "error": str(e)}
    
    async def check_status_handler(self, params: dict) -> dict:
        """Check the status of a clip generation job."""
        job_id = params.get("job_id", "")
        
        if not job_id:
            return {"success": False, "error": "job_id is required"}
        
        api_key = self.api.get_config("clipper_api_key", "")
        if not api_key:
            return {"success": False, "error": "Clipper API key not configured"}
        
        api_url = self.api.get_config("clipper_api_url", self.DEFAULT_CLIPPER_URL)
        
        try:
            response = await self.api.http_request(
                method="GET",
                url=f"{api_url}/api/v1/clippy/jobs/{job_id}",
                headers={"Authorization": f"Bearer {api_key}"},
                timeout=30.0
            )
            
            if response["status_code"] != 200:
                return {"success": False, "error": f"Failed to get job status: {response['status_code']}"}
            
            result = json.loads(response["body"])
            
            # If job is complete and has clips, auto-save them
            if result.get("status") == "completed" and result.get("clips"):
                if self.api.get_config("auto_save_clips", True):
                    await self._save_clips_as_memories(
                        result["clips"],
                        result.get("videoUrl", ""),
                        result.get("prompt", "")
                    )
            
            return {
                "success": True,
                "result": {
                    "job_id": job_id,
                    "status": result.get("status"),
                    "progress": result.get("progress", 0),
                    "clips_count": len(result.get("clips", [])),
                    "clips": result.get("clips", []),
                    "error": result.get("error")
                }
            }
            
        except Exception as e:
            self.api.log("error", f"Status check error: {e}")
            return {"success": False, "error": str(e)}
    
    async def get_clip_handler(self, params: dict) -> dict:
        """Get details for a specific clip."""
        clip_id = params.get("clip_id", "")
        
        if not clip_id:
            return {"success": False, "error": "clip_id is required"}
        
        api_key = self.api.get_config("clipper_api_key", "")
        if not api_key:
            return {"success": False, "error": "Clipper API key not configured"}
        
        api_url = self.api.get_config("clipper_api_url", self.DEFAULT_CLIPPER_URL)
        
        try:
            response = await self.api.http_request(
                method="GET",
                url=f"{api_url}/api/v1/clippy/clips/{clip_id}",
                headers={"Authorization": f"Bearer {api_key}"},
                timeout=30.0
            )
            
            if response["status_code"] != 200:
                return {"success": False, "error": f"Failed to get clip: {response['status_code']}"}
            
            result = json.loads(response["body"])
            
            return {
                "success": True,
                "result": {
                    "clip_id": clip_id,
                    "title": result.get("title"),
                    "description": result.get("description"),
                    "duration": result.get("duration"),
                    "start_time": result.get("startTime"),
                    "end_time": result.get("endTime"),
                    "download_url": result.get("downloadUrl"),
                    "thumbnail_url": result.get("thumbnailUrl"),
                    "captions": result.get("captions"),
                    "aspect_ratio": result.get("aspectRatio"),
                    "platform_recommendation": result.get("platformRecommendation")
                }
            }
            
        except Exception as e:
            self.api.log("error", f"Get clip error: {e}")
            return {"success": False, "error": str(e)}
    
    async def configure_handler(self, params: dict) -> dict:
        """Show current Clippy configuration status.
        
        Settings are now managed via the Plugin Settings UI.
        Go to Settings > Plugins > Clippy Video Clipper to configure.
        """
        api_url = self.api.get_config("clipper_api_url", self.DEFAULT_CLIPPER_URL)
        api_key = self.api.get_config("clipper_api_key", "")
        auto_save = self.api.get_config("auto_save_clips", True)
        
        return {
            "success": True,
            "result": {
                "message": "Clippy settings are managed via Settings > Plugins > Clippy Video Clipper",
                "current_api_url": api_url,
                "api_key_configured": bool(api_key),
                "auto_save_clips": auto_save
            }
        }
    
    async def _save_clips_as_memories(
        self,
        clips: list[dict],
        video_url: str,
        prompt: str,
        job_id: str | None = None
    ) -> None:
        """Save generated clips to the clips library in ThinkOS."""
        for clip in clips:
            try:
                title = clip.get("title", "Untitled Clip")
                
                # Build tags list
                tags = ["clippy"]
                if clip.get("platformRecommendation"):
                    tags.append(clip["platformRecommendation"])
                
                # Save to dedicated clips table
                await self.api.save_video_clip(
                    title=title,
                    source_url=video_url,
                    description=clip.get("description"),
                    start_time=clip.get("startTime"),
                    end_time=clip.get("endTime"),
                    duration=clip.get("duration"),
                    thumbnail_url=clip.get("thumbnailUrl"),
                    download_url=clip.get("downloadUrl"),
                    preview_url=clip.get("previewUrl"),
                    aspect_ratio=clip.get("aspectRatio"),
                    platform_recommendation=clip.get("platformRecommendation"),
                    captions=clip.get("captions"),
                    prompt=prompt,
                    clippy_job_id=job_id,
                    clippy_clip_id=clip.get("id"),
                    tags=tags,
                )
                
                self.api.log("info", f"Saved clip to library: {title}")
                
            except Exception as e:
                self.api.log("warning", f"Failed to save clip: {e}")
